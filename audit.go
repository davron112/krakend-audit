package audit

import (
	"github.com/luraproject/lura/v2/config"
)

// Audit audits the received configuration and generates an AuditResult with all the Recommendations
func Audit(cfg *config.ServiceConfig, ignore, severities []string) (AuditResult, error) {
	service := Parse(cfg)

	res := AuditResult{Recommendations: []Recommendation{}}
	keysToIgnore := map[string]struct{}{}
	for _, k := range ignore {
		keysToIgnore[k] = struct{}{}
	}
	severitiesToCatch := map[string]struct{}{}
	for _, k := range severities {
		severitiesToCatch[k] = struct{}{}
	}

	for i := range ruleSet {
		if _, ok := keysToIgnore[ruleSet[i].Recommendation.Rule]; ok {
			continue
		}

		if _, ok := severitiesToCatch[ruleSet[i].Recommendation.Severity]; !ok {
			continue
		}

		if ruleSet[i].Evaluate(&service) {
			res.Recommendations = append(res.Recommendations, ruleSet[i].Recommendation)
		}
	}

	return res, nil
}

const (
	SeverityCritical = "CRITICAL"
	SeverityHigh     = "HIGH"
	SeverityMedium   = "MEDIUM"
	SeverityLow      = "LOW"
)

// Rule encapsulates a recommendation and an evaluation function that determines if the recommendation
// applies for a given service definition
type Rule struct {
	Recommendation Recommendation
	Evaluate       func(*Service) bool
}

// NewRule creates a Rule with the given arguments
func NewRule(id, severity, msg string, ef func(*Service) bool) Rule {
	return Rule{
		Recommendation: Recommendation{
			Rule:     id,
			Severity: severity,
			Message:  msg,
		},
		Evaluate: ef,
	}
}

// AuditResult contains all the recommendations and stats generated by the audit process
type AuditResult struct {
	Recommendations []Recommendation `json:"recommendations"`
	Stats           Stats            `json:"stats"`
}

// Recommendation maps a rule id with a severity and a message
type Recommendation struct {
	Rule     string `json:"rule"`
	Severity string `json:"severity"`
	Message  string `json:"message"`
}

// Stats is an empty struct that will be completed in the future
type Stats struct{}

var ruleSet = []Rule{
	NewRule("1.1.1", SeverityHigh, "Ensure that Basic Auth is not used.", hasBasicAuth),
	NewRule("1.1.2", SeverityMedium, "Ensure to protect your endpoints with stateless authorization methods such as JWT. Avoid API keys.", hasApiKeys),
	NewRule("1.2.1", SeverityHigh, "Ensure to protect your endpoints with authorization, preferably with JWT.", hasNoJWT),
	NewRule("2.1.1", SeverityHigh, "Ensure that you don't allow insecure connections.", hasInsecureConnections),
	NewRule("2.1.2", SeverityHigh, "Ensure you enable TLS or use a terminator in front of KrakenD.", hasNoTLS),
	NewRule("2.1.3", SeverityCritical, "Ensure your TLS is enabled.", hasTLSDisabled),
	NewRule("2.1.7", SeverityHigh, "Ensure you enable HTTP security header checks (security/http).", hasNoHTTPSecure),
	NewRule("2.2.1", SeverityMedium, "Ensure that the version banner is hidden in runtime.", hasNoObfuscatedVersionHeader),
	NewRule("2.2.2", SeverityHigh, "Ensure that CORS is enabled.", hasNoCORS),
	NewRule("3.1.1", SeverityMedium, "Ensure that the Bot detector is enabled.", hasBotdetectorDisabled),
	NewRule("3.1.2", SeverityMedium, "Ensure you enable some rate-limiting strategy and avoid having an All-You-Can-Eat API.", hasNoRatelimit),
	NewRule("3.1.3", SeverityMedium, "Ensure you protect your backends with a circuit breaker.", hasNoCB),
	NewRule("3.3.1", SeverityLow, "Ensure that your timeouts are below 3 seconds.", hasTimeoutBiggerThan(3000)),
	NewRule("3.3.2", SeverityMedium, "Ensure that your timeouts are below 5 seconds.", hasTimeoutBiggerThan(5000)),
	NewRule("3.3.3", SeverityHigh, "Ensure that your timeouts are below 30 seconds.", hasTimeoutBiggerThan(30000)),
	NewRule("3.3.4", SeverityCritical, "Ensure that your timeouts are below 60 seconds.", hasTimeoutBiggerThan(60000)),
	NewRule("4.1.1", SeverityMedium, "Ensure that you have some telemetry system for metrics.", hasNoMetrics),
	NewRule("4.1.3", SeverityHigh, "Ensure not to overload the system with duplicated telemetry options.", hasSeveralTelemetryComponents),
	NewRule("4.2.1", SeverityMedium, "Ensure that you have some telemetry system for tracing.", hasNoTracing),
	NewRule("4.3.1", SeverityMedium, "Ensure that you have the improved logging component, which improves log parsing.", hasNoLogging),
	NewRule("5.1.1", SeverityLow, "Ensure your endpoint structure is RESTful.", hasRestfulDisabled),
	NewRule("5.1.2", SeverityLow, "Ensure that the /__debug/ endpoint is not enabled.", hasDebugEnabled),
	NewRule("5.2.1", SeverityCritical, "Ensure all your endpoints contain at least one backend.", hasEndpointWithoutBackends),
	NewRule("5.2.2", SeverityLow, "Ensure you don't use the gateway solely as a reverse proxy (1 backend per endpoint).", hasASingleBackendPerEndpoint),
	NewRule("5.2.3", SeverityLow, "Ensure you don't couple your clients by abusing no-op encoding.", hasAllEndpointsAsNoop),
	NewRule("6.1.1", SeverityLow, "Ensure that Async Agents do not start sequentially (+10 agents).", hasSequentialStart),
}
